package authentication_business_layer

import (
	"context"
	goerrors "errors"
	"fmt"
	"strings"

	pixiecontext "github.com/pixie-sh/core-go/pkg/context"
	"github.com/pixie-sh/core-go/pkg/errors/db_errors"
	"github.com/pixie-sh/core-go/pkg/uid"
	"github.com/pixie-sh/database-helpers-go/database"
	"github.com/pixie-sh/di-go"
	"github.com/pixie-sh/errors-go"
	"github.com/pixie-sh/logger-go/logger"
	"gorm.io/gorm"

	internaldi "{{ .ModuleName }}/infra/di"
	"{{ .ModuleName }}/infra/event"
	data "{{ .ModuleName }}/internal/domains/authentication/authentication_data_layer"
	"{{ .ModuleName }}/internal/domains/authentication/authentication_data_layer/auth_entities"
	"{{ .ModuleName }}/internal/domains/authentication/authentication_services"
)

// PasswordBusinessLayerConfiguration holds configuration for password operations.
type PasswordBusinessLayerConfiguration struct {
	PasswordDataLayerConfiguration data.PasswordDataLayerConfiguration                  `json:"password_data_layer"`
	PasswordServiceConfiguration   authentication_services.PasswordServiceConfiguration `json:"password_service"`
	UserServiceConfiguration       authentication_services.UserServiceConfiguration     `json:"user_service"`
}

func (p PasswordBusinessLayerConfiguration) LookupNode(lookupPath string) (any, error) {
	return di.ConfigurationNodeLookup(p, lookupPath)
}

// PasswordBusinessLayer handles password-related business logic including recovery and change.
type PasswordBusinessLayer struct {
	config          PasswordBusinessLayerConfiguration
	passwordService authentication_services.PasswordService
	userService     authentication_services.UserService
	loginService    authentication_services.LoginService
	dataLayer       data.PasswordDataLayer
}

// NewPasswordBusinessLayer creates a new PasswordBusinessLayer instance.
func NewPasswordBusinessLayer(
	ctx context.Context,
	config PasswordBusinessLayerConfiguration,
	passwordDataLayer data.PasswordDataLayer,
	passwordService authentication_services.PasswordService,
	loginService authentication_services.LoginService,
	userService authentication_services.UserService,
) (PasswordBusinessLayer, error) {
	l := PasswordBusinessLayer{
		config:          config,
		dataLayer:       passwordDataLayer,
		passwordService: passwordService,
		loginService:    loginService,
		userService:     userService,
	}

	return l, l.InitLayer(ctx)
}

// InitLayer initializes the business layer.
func (l PasswordBusinessLayer) InitLayer(_ context.Context) error {
	logger.Debug("empty init layer for PasswordBusinessLayer")
	return nil
}

// Defer performs cleanup operations.
func (l PasswordBusinessLayer) Defer() {}

// RegistryPasswordBusinessLayerConfiguration creates a configuration from DI context.
func RegistryPasswordBusinessLayerConfiguration(ctx di.Context, opts *di.RegistryOpts) (*PasswordBusinessLayerConfiguration, error) {
	return di.ConfigurationLookup[*PasswordBusinessLayerConfiguration](ctx, opts)
}

// RegistryPasswordBusinessLayer creates a PasswordBusinessLayer from DI context.
func RegistryPasswordBusinessLayer(ctx di.Context, opts *di.RegistryOpts) (*PasswordBusinessLayer, error) {
	log := pixiecontext.GetCtxLogger(ctx)

	cfg, err := di.CreateConfiguration[*PasswordBusinessLayerConfiguration](ctx, di.WithOpts(opts))
	if err != nil {
		return nil, err
	}

	passwordDataLayer, err := di.Create[*data.PasswordDataLayer](ctx, di.WithOpts(opts), di.WithToken(internaldi.RegistryTokenPasswordDataLayer))
	if err != nil {
		log.With("err", err).Error("Failed to initialize %s for %s", internaldi.RegistryTokenPasswordDataLayer, internaldi.RegistryTokenPasswordBusinessLayer)
		return nil, err
	}

	passwordService, err := di.Create[*authentication_services.PasswordService](ctx, di.WithOpts(opts), di.WithToken(internaldi.RegistryTokenPasswordService))
	if err != nil {
		log.With("err", err).Error("Failed to initialize %s for %s", internaldi.RegistryTokenPasswordService, internaldi.RegistryTokenPasswordBusinessLayer)
		return nil, err
	}

	userService, err := di.Create[*authentication_services.UserService](ctx, di.WithOpts(opts), di.WithToken(internaldi.RegistryTokenUserService))
	if err != nil {
		log.With("err", err).Error("Failed to initialize %s for %s", internaldi.RegistryTokenUserService, internaldi.RegistryTokenPasswordBusinessLayer)
		return nil, err
	}

	loginService, err := di.Create[*authentication_services.LoginService](ctx, di.WithOpts(opts), di.WithToken(internaldi.RegistryTokenAuthenticationLoginService))
	if err != nil {
		log.With("err", err).Error("Failed to initialize %s for %s", internaldi.RegistryTokenAuthenticationLoginService, internaldi.RegistryTokenPasswordBusinessLayer)
		return nil, err
	}

	passwordBusiness, err := NewPasswordBusinessLayer(ctx, *cfg, *passwordDataLayer, *passwordService, *loginService, *userService)
	if err != nil {
		return nil, err
	}

	return &passwordBusiness, nil
}

// VerifyPasswordRecoveryWithCodeBy verifies a password recovery code and sets a new password.
func (l PasswordBusinessLayer) VerifyPasswordRecoveryWithCodeBy(ctx context.Context, emailOrPhone string, value string, code string, newPassword string) error {
	var txVal error
	txErr := l.dataLayer.Transaction(ctx, func(tx *gorm.DB) error {
		txUserService := l.userService.WithTx(tx)
		txPasswordService := l.passwordService.WithTx(tx)
		var user auth_entities.User
		var err error

		if emailOrPhone == "email" {
			email := strings.ToLower(value)
			user, err = txUserService.GetByEmail(ctx, email)
			if err != nil && !goerrors.Is(err, gorm.ErrRecordNotFound) {
				return err
			}
		}

		if user.ID != uid.Nil {
			resetCodes, err := txPasswordService.VerifyUnusedResetTokensForUserID(ctx, user.ID)
			if err != nil {
				return err
			}

			for _, resetCode := range resetCodes {
				if resetCode.Token == code {
					err = txPasswordService.MarkAsConfirmed(ctx, resetCode.ID)
					if err != nil {
						return err
					}

					return txUserService.UpdateUserPassword(ctx, user.ID, newPassword)
				}
			}
		}

		txVal = errors.New("Validation failed", errors.FieldError{
			Field:   "token",
			Rule:    "not_found",
			Message: "Token or account not found",
		})
		return nil
	})

	if txErr != nil {
		return txErr
	}

	return txVal
}

// PasswordChangeByUserID changes the password for a user after validating the current password.
func (l PasswordBusinessLayer) PasswordChangeByUserID(ctx context.Context, userID uid.UID, currentPassword string, newPassword string) error {
	return l.dataLayer.Transaction(ctx, func(tx *gorm.DB) error {
		txLoginService := l.loginService.WithTx(tx)
		txUserService := l.userService.WithTx(tx)

		_, err := txLoginService.ValidatePasswordByUserID(ctx, userID, currentPassword)
		if err != nil {
			return err
		}

		err = txUserService.UpdateUserPassword(ctx, userID, newPassword)
		return err
	})
}

// SendPasswordRecoveryByEmail initiates password recovery by sending an OTP to the user's email.
func (l PasswordBusinessLayer) SendPasswordRecoveryByEmail(ctx context.Context, ip string, agent string, email string) error {
	err := l.dataLayer.Transaction(ctx, func(tx *database.DB) error {
		txUserService := l.userService.WithTx(tx)

		// Force email to be lowercase for consistent lookup
		email := strings.ToLower(email)

		user, err := txUserService.GetByEmail(ctx, email)
		if err != nil {
			return db_errors.Handle(err)
		}

		reset, err := l.passwordService.CreateNewResetToken(ctx, ip, agent, user.ID)
		if err != nil {
			return err
		}

		ev := event.NewPasswordRecoveryOTPEmailEvent(
			fmt.Sprintf("user-%d-%s", user.ID, reset.Token),
			user.ID,
			user.EmailAddress,
			reset.Token,
			reset.ValidUntil,
			ip,
			agent,
		)

		err = ev.Emit(ctx)
		if err != nil {
			pixiecontext.GetCtxLogger(ctx).With("error", err).With("event", ev).Error("error producing event %s", ev.PayloadType)
			return nil
		}

		return err
	})

	if err != nil {
		pixiecontext.GetCtxLogger(ctx).With("error", err).Error("error processing request; or user by email %s not found or event failed to be sent", email)
		return nil
	}

	return nil
}
