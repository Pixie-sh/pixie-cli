package authentication_business_layer

import (
	"context"
	"crypto/rand"
	"encoding/hex"
	"time"

	pixiecontext "github.com/pixie-sh/core-go/pkg/context"
	"github.com/pixie-sh/core-go/pkg/errors/db_errors"
	"github.com/pixie-sh/core-go/pkg/uid"
	"github.com/pixie-sh/database-helpers-go/database"
	"github.com/pixie-sh/di-go"
	"github.com/pixie-sh/errors-go"
	"github.com/pixie-sh/logger-go/logger"
	"gorm.io/gorm"

	internaldi "{{ .ModuleName }}/infra/di"
	"{{ .ModuleName }}/infra/apis"
	"{{ .ModuleName }}/infra/session_manager"
	data "{{ .ModuleName }}/internal/domains/authentication/authentication_data_layer"
	"{{ .ModuleName }}/internal/domains/authentication/authentication_data_layer/auth_entities"
	"{{ .ModuleName }}/internal/domains/authentication/authentication_services"
	"{{ .ModuleName }}/pkg/models/auth"
	"{{ .ModuleName }}/pkg/models/session_manager_models"
)

// GoogleAuthBusinessLayerConfiguration holds configuration for the Google auth business layer
type GoogleAuthBusinessLayerConfiguration struct {
	AuthDataLayerConfiguration    data.AuthenticationDataLayerConfiguration               `json:"auth_data_layer"`
	GoogleAuthServiceConfiguration authentication_services.GoogleAuthServiceConfiguration `json:"google_auth_service"`
	LoginServiceConfiguration      authentication_services.LoginServiceConfiguration      `json:"auth_login_service"`
}

func (g GoogleAuthBusinessLayerConfiguration) LookupNode(lookupPath string) (any, error) {
	return di.ConfigurationNodeLookup(g, lookupPath)
}

// GoogleAuthBusinessLayer orchestrates the Google OAuth flow
type GoogleAuthBusinessLayer struct {
	config            GoogleAuthBusinessLayerConfiguration
	dataLayer         *data.AuthenticationDataLayer
	googleAuthService *authentication_services.GoogleAuthService
	loginService      *authentication_services.LoginService
}

// RegistryGoogleAuthBusinessLayerConfiguration creates a configuration from DI context
func RegistryGoogleAuthBusinessLayerConfiguration(ctx di.Context, opts *di.RegistryOpts) (*GoogleAuthBusinessLayerConfiguration, error) {
	return di.ConfigurationLookup[*GoogleAuthBusinessLayerConfiguration](ctx, opts)
}

// RegistryGoogleAuthBusinessLayer creates a GoogleAuthBusinessLayer from DI context
func RegistryGoogleAuthBusinessLayer(ctx di.Context, opts *di.RegistryOpts) (*GoogleAuthBusinessLayer, error) {
	log := pixiecontext.GetCtxLogger(ctx)

	cfg, err := di.CreateConfiguration[*GoogleAuthBusinessLayerConfiguration](ctx, di.WithOpts(opts))
	if err != nil {
		return nil, err
	}

	authDataLayer, err := di.Create[*data.AuthenticationDataLayer](ctx, di.WithOpts(opts), di.WithToken(internaldi.RegistryTokenAuthenticationDataLayer))
	if err != nil {
		log.With("err", err).Error("Failed to initialize %s for %s", internaldi.RegistryTokenAuthenticationDataLayer, internaldi.RegistryTokenGoogleAuthBusinessLayer)
		return nil, err
	}

	googleAuthService, err := di.Create[*authentication_services.GoogleAuthService](ctx, di.WithOpts(opts), di.WithToken(internaldi.RegistryTokenGoogleAuthService))
	if err != nil {
		return nil, err
	}

	loginService, err := di.Create[*authentication_services.LoginService](ctx, di.WithOpts(opts), di.WithToken(internaldi.RegistryTokenAuthenticationLoginService))
	if err != nil {
		return nil, err
	}

	return NewGoogleAuthBusinessLayer(ctx, *cfg, authDataLayer, googleAuthService, loginService)
}

// NewGoogleAuthBusinessLayer creates a new GoogleAuthBusinessLayer instance
func NewGoogleAuthBusinessLayer(
	ctx context.Context,
	config GoogleAuthBusinessLayerConfiguration,
	dataLayer *data.AuthenticationDataLayer,
	googleAuthService *authentication_services.GoogleAuthService,
	loginService *authentication_services.LoginService,
) (*GoogleAuthBusinessLayer, error) {
	l := &GoogleAuthBusinessLayer{
		config:            config,
		dataLayer:         dataLayer,
		googleAuthService: googleAuthService,
		loginService:      loginService,
	}

	return l, l.InitLayer(ctx)
}

// InitLayer initializes the business layer
func (l GoogleAuthBusinessLayer) InitLayer(_ context.Context) error {
	logger.Debug("empty init layer for GoogleAuthBusinessLayer")
	return nil
}

// InitiateGoogleAuth generates a Google OAuth consent URL for login
func (l GoogleAuthBusinessLayer) InitiateGoogleAuth(ctx context.Context, channel session_manager_models.SessionChannel) (auth.GoogleAuthInitiateResponse, error) {
	csrfToken, err := generateCSRFToken()
	if err != nil {
		return auth.GoogleAuthInitiateResponse{}, errors.NewWithError(err, "failed to generate CSRF token")
	}

	nonce, err := generateCSRFToken()
	if err != nil {
		return auth.GoogleAuthInitiateResponse{}, errors.NewWithError(err, "failed to generate nonce")
	}

	stateData := apis.GoogleOAuthStateData{
		CSRFToken: csrfToken,
		Nonce:     nonce,
		Intent:    "login",
	}

	consentURL, err := l.googleAuthService.GenerateAuthURL(stateData)
	if err != nil {
		return auth.GoogleAuthInitiateResponse{}, err
	}

	return auth.GoogleAuthInitiateResponse{
		AuthURL: consentURL,
	}, nil
}

// HandleGoogleCallback handles the Google OAuth callback for login
func (l GoogleAuthBusinessLayer) HandleGoogleCallback(ctx context.Context, code string, state string, channel session_manager_models.SessionChannel, ip string) (auth.LoginResponse, error) {
	var loginResponse auth.LoginResponse
	var user auth_entities.User
	var entities []session_manager_models.JWTEntity
	var userType = auth_entities.UserType
	var err error

	// Validate callback and get user info
	userInfo, err := l.googleAuthService.ValidateGoogleCallback(ctx, code, state)
	if err != nil {
		return loginResponse, err
	}

	// Resolve or create user within a transaction
	err = l.dataLayer.Transaction(ctx, func(tx *gorm.DB) error {
		txGoogleService := l.googleAuthService.WithTx(tx)
		txLoginService := l.loginService.WithTx(tx)

		user, err = txGoogleService.ResolveOrCreateUser(ctx, userInfo)
		if err != nil {
			return db_errors.Handle(err)
		}

		entities, userType, err = txLoginService.FindUserEntitiesByUserID(ctx, user.ID)
		if err != nil {
			return db_errors.Handle(err)
		}

		return nil
	}, &database.TxOptions{
		Isolation: database.IsolationLevelReadCommitted,
	})

	if err != nil {
		return loginResponse, err
	}

	// Build login response (follows same pattern as auth_business_layer.go.tmpl)
	loginResponse, err = l.buildLoginResponse(ctx, user.ID, user.EmailAddress, channel, ip, entities, userType)
	if err != nil {
		return loginResponse, db_errors.Handle(err)
	}

	err = l.loginService.UpdateLastLoginInfo(ctx, user.ID, ip)
	if err != nil {
		logger.With("err", err).Error("Failed to update last login and last ip")
		return loginResponse, db_errors.Handle(err)
	}

	return loginResponse, nil
}

// InitiateGoogleLink generates a Google OAuth consent URL for account linking
func (l GoogleAuthBusinessLayer) InitiateGoogleLink(ctx context.Context) (auth.GoogleAuthInitiateResponse, error) {
	csrfToken, err := generateCSRFToken()
	if err != nil {
		return auth.GoogleAuthInitiateResponse{}, errors.NewWithError(err, "failed to generate CSRF token")
	}

	nonce, err := generateCSRFToken()
	if err != nil {
		return auth.GoogleAuthInitiateResponse{}, errors.NewWithError(err, "failed to generate nonce")
	}

	stateData := apis.GoogleOAuthStateData{
		CSRFToken: csrfToken,
		Nonce:     nonce,
		Intent:    "link",
	}

	consentURL, err := l.googleAuthService.GenerateAuthURL(stateData)
	if err != nil {
		return auth.GoogleAuthInitiateResponse{}, err
	}

	return auth.GoogleAuthInitiateResponse{
		AuthURL: consentURL,
	}, nil
}

// HandleGoogleLinkCallback handles the Google OAuth callback for account linking
func (l GoogleAuthBusinessLayer) HandleGoogleLinkCallback(ctx context.Context, userID uid.UID, code string, state string) error {
	// Validate callback and get user info
	userInfo, err := l.googleAuthService.ValidateGoogleCallback(ctx, code, state)
	if err != nil {
		return err
	}

	// Link account within a transaction
	return l.dataLayer.Transaction(ctx, func(tx *gorm.DB) error {
		txGoogleService := l.googleAuthService.WithTx(tx)
		return txGoogleService.LinkGoogleAccount(ctx, userID, userInfo)
	}, &database.TxOptions{
		Isolation: database.IsolationLevelReadCommitted,
	})
}

// UnlinkGoogleAccount removes the Google account link for a user
func (l GoogleAuthBusinessLayer) UnlinkGoogleAccount(ctx context.Context, userID uid.UID) error {
	return l.dataLayer.Transaction(ctx, func(tx *gorm.DB) error {
		txGoogleService := l.googleAuthService.WithTx(tx)
		return txGoogleService.UnlinkGoogleAccount(ctx, userID)
	}, &database.TxOptions{
		Isolation: database.IsolationLevelReadCommitted,
	})
}

// GetLinkedGoogleAccount returns the linked Google account for a user
func (l GoogleAuthBusinessLayer) GetLinkedGoogleAccount(ctx context.Context, userID uid.UID) (auth.GoogleLinkedAccountResponse, error) {
	account, err := l.googleAuthService.GetLinkedGoogleAccount(ctx, userID)
	if err != nil {
		return auth.GoogleLinkedAccountResponse{}, err
	}

	return auth.GoogleLinkedAccountResponse{
		GoogleID:   account.GoogleID,
		Email:      account.Email,
		Name:       account.Name,
		PictureURL: account.PictureURL,
		LinkedAt:   account.CreatedAt,
	}, nil
}

// buildLoginResponse constructs the login response with JWT token and session
// This follows the same pattern as AuthenticationBusinessLayer.buildLoginResponse
func (l GoogleAuthBusinessLayer) buildLoginResponse(
	ctx context.Context,
	userID uid.UID,
	email string,
	channel session_manager_models.SessionChannel,
	ip string,
	entities []session_manager_models.JWTEntity,
	userType auth_entities.UserTypeEnum,
) (auth.LoginResponse, error) {
	var loginResp auth.LoginResponse
	var err error

	timeNow := time.Now()
	jwt, err := session_manager.GenerateJWT(ctx, userID, email, ip, channel, entities)
	if err != nil {
		return loginResp, err
	}
	logger.Debug("elapsed on generate token %d ms", time.Since(timeNow).Milliseconds())

	var userSession session_manager_models.UntypedSession
	switch userType {
	case auth_entities.SuperAdminUserType:
		adminSession := session_manager.GenerateAdminSessionFromJWT(ctx, jwt)
		userSession = adminSession.UntypedSession
	case auth_entities.UserType:
		partnerSession := session_manager.GenerateUserSessionFromJWT(ctx, jwt)
		userSession = partnerSession.UntypedSession
	default:
		pixiecontext.GetCtxLogger(ctx).With("user_type", userType).Error("unknown user type, no session created")
		return auth.LoginResponse{}, errors.New("unknown user type %d", userType).WithErrorCode(errors.UnknownErrorCode)
	}

	return auth.LoginResponse{Token: jwt.EncodedJWT}, session_manager.Save(ctx, jwt, userSession)
}

// Defer performs cleanup operations
func (l GoogleAuthBusinessLayer) Defer() {}

// generateCSRFToken generates a random CSRF token
func generateCSRFToken() (string, error) {
	bytes := make([]byte, 32)
	if _, err := rand.Read(bytes); err != nil {
		return "", err
	}
	return hex.EncodeToString(bytes), nil
}
