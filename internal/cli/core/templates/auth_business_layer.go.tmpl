package authentication_business_layer

import (
	"context"
	"strings"
	"time"

	pixiecontext "github.com/pixie-sh/core-go/pkg/context"
	"github.com/pixie-sh/core-go/pkg/errors/db_errors"
	"github.com/pixie-sh/core-go/pkg/uid"
	"github.com/pixie-sh/database-helpers-go/database"
	"github.com/pixie-sh/di-go"
	"github.com/pixie-sh/errors-go"
	"github.com/pixie-sh/logger-go/logger"
	"gorm.io/gorm"

	internaldi "{{ .ModuleName }}/infra/di"
	"{{ .ModuleName }}/infra/session_manager"
	"{{ .ModuleName }}/internal/adapters/authentication_adapters"
	data "{{ .ModuleName }}/internal/domains/authentication/authentication_data_layer"
	"{{ .ModuleName }}/internal/domains/authentication/authentication_data_layer/auth_entities"
	"{{ .ModuleName }}/internal/domains/authentication/authentication_services"
	"{{ .ModuleName }}/pkg/models/auth"
	"{{ .ModuleName }}/pkg/models/session_manager_models"
)

// AuthenticationBusinessLayerConfiguration holds configuration for the authentication business layer.
type AuthenticationBusinessLayerConfiguration struct {
	AuthDataLayerConfiguration data.AuthenticationDataLayerConfiguration             `json:"auth_data_layer"`
	LoginServiceConfiguration  authentication_services.LoginServiceConfiguration `json:"auth_login_service"`
}

func (a AuthenticationBusinessLayerConfiguration) LookupNode(lookupPath string) (any, error) {
	return di.ConfigurationNodeLookup(a, lookupPath)
}

// AuthenticationBusinessLayer handles authentication business logic including login, logout, and session management.
type AuthenticationBusinessLayer struct {
	config       AuthenticationBusinessLayerConfiguration
	dataLayer    *data.AuthenticationDataLayer
	loginService *authentication_services.LoginService
	adapters     *authentication_adapters.UserAdapter
}

// RegistryAuthenticationBusinessLayerConfiguration creates a configuration from DI context.
func RegistryAuthenticationBusinessLayerConfiguration(ctx di.Context, opts *di.RegistryOpts) (*AuthenticationBusinessLayerConfiguration, error) {
	return di.ConfigurationLookup[*AuthenticationBusinessLayerConfiguration](ctx, opts)
}

// RegistryAuthenticationBusinessLayer creates an AuthenticationBusinessLayer from DI context.
func RegistryAuthenticationBusinessLayer(ctx di.Context, opts *di.RegistryOpts) (*AuthenticationBusinessLayer, error) {
	log := pixiecontext.GetCtxLogger(ctx)

	cfg, err := di.CreateConfiguration[*AuthenticationBusinessLayerConfiguration](ctx, di.WithOpts(opts))
	if err != nil {
		return nil, err
	}

	authenticationDataLayer, err := di.Create[*data.AuthenticationDataLayer](ctx, di.WithOpts(opts), di.WithToken(internaldi.RegistryTokenAuthenticationDataLayer))
	if err != nil {
		log.With("err", err).Error("Failed to initialize %s for %s", internaldi.RegistryTokenAuthenticationDataLayer, internaldi.RegistryTokenAuthenticationBusinessLayer)
		return nil, err
	}

	loginService, err := di.Create[*authentication_services.LoginService](ctx, di.WithOpts(opts), di.WithToken(internaldi.RegistryTokenAuthenticationLoginService))
	if err != nil {
		return nil, err
	}

	return NewAuthenticationBusinessLayer(
		ctx,
		*cfg,
		authenticationDataLayer,
		loginService,
		authentication_adapters.NewUserAdapter(),
	)
}

// NewAuthenticationBusinessLayer creates a new AuthenticationBusinessLayer instance.
func NewAuthenticationBusinessLayer(
	ctx context.Context,
	config AuthenticationBusinessLayerConfiguration,
	authDataLayer *data.AuthenticationDataLayer,
	loginService *authentication_services.LoginService,
	adapters *authentication_adapters.UserAdapter,
) (*AuthenticationBusinessLayer, error) {
	l := &AuthenticationBusinessLayer{
		config:       config,
		dataLayer:    authDataLayer,
		loginService: loginService,
		adapters:     adapters,
	}

	return l, l.InitLayer(ctx)
}

// InitLayer initializes the business layer.
func (l AuthenticationBusinessLayer) InitLayer(_ context.Context) error {
	logger.Debug("empty init layer for AuthenticationBusinessLayer")
	return nil
}

// Login authenticates a user with credentials and returns a JWT token.
func (l AuthenticationBusinessLayer) Login(ctx context.Context, credentials auth.LoginCredentialsRequest, ip string) (auth.LoginResponse, error) {
	var err error
	var user auth_entities.User
	var loginResponse auth.LoginResponse
	var entities []session_manager_models.JWTEntity
	var userType = auth_entities.UserType

	err = l.dataLayer.Transaction(ctx, func(tx *gorm.DB) error {
		txLoginService := l.loginService.WithTx(tx)

		if len(credentials.Email) > 0 {
			user, err = txLoginService.ValidateLoginWithEmail(ctx, credentials.Channel, credentials.Email, credentials.Password)
			if err != nil {
				return db_errors.Handle(err)
			}
		}

		entities, userType, err = txLoginService.FindUserEntitiesByUserID(ctx, user.ID)
		if err != nil {
			return db_errors.Handle(err)
		}

		return err
	}, &database.TxOptions{
		Isolation: database.IsolationLevelReadCommitted,
		ReadOnly:  true,
	})

	if err != nil {
		return loginResponse, err
	}

	loginResponse, err = l.buildLoginResponse(ctx, user.ID, user.EmailAddress, credentials.Channel, ip, entities, userType)
	if err != nil {
		return loginResponse, db_errors.Handle(err)
	}

	err = l.loginService.UpdateLastLoginInfo(ctx, user.ID, ip)
	if err != nil {
		logger.With("err", err).Error("Failed to update last login and last ip")
		return loginResponse, db_errors.Handle(err)
	}

	return loginResponse, nil
}

// LoginAs allows a super admin to login as another user.
func (l AuthenticationBusinessLayer) LoginAs(ctx context.Context, credentials auth.LoginAsCredentialsRequest, ip string) (auth.LoginResponse, error) {
	var err error
	var user auth_entities.User
	var loginResponse auth.LoginResponse

	err = l.dataLayer.Transaction(ctx, func(tx *gorm.DB) error {
		txLoginService := l.loginService.WithTx(tx)

		user, err = txLoginService.ValidateLoginWithEmail(ctx, credentials.Channel, credentials.Email, credentials.Password)
		if err != nil {
			return err
		}

		loginAsEmailLowerCase := strings.ToLower(credentials.LoginAsEmail)
		if user.UserType != auth_entities.SuperAdminUserType {
			return errors.New("Unauthorized").WithErrorCode(errors.UnauthorizedErrorCode)
		}

		userToLogin, err := txLoginService.FindUserForLoginValidationByEmail(ctx, loginAsEmailLowerCase)
		if err != nil {
			return err
		}

		loginResponse, err = l.buildLoginResponse(ctx, userToLogin.ID, userToLogin.EmailAddress, credentials.Channel, ip, nil, userToLogin.UserType)
		return err
	}, &database.TxOptions{
		Isolation: database.IsolationLevelReadCommitted,
		ReadOnly:  true,
	})

	if err != nil {
		return auth.LoginResponse{}, err
	}

	err = l.loginService.UpdateLastLoginInfo(ctx, user.ID, ip)
	if err != nil {
		logger.With("err", err).Error("Failed to update last login and last ip")
		return auth.LoginResponse{}, db_errors.Handle(err)
	}

	return loginResponse, nil
}

// KeepTokenAlive refreshes a JWT token to extend its validity.
func (l AuthenticationBusinessLayer) KeepTokenAlive(ctx context.Context, tokenStr string, jwt session_manager_models.JWT, ip string) error {
	return session_manager.Refresh(ctx, tokenStr)
}

// Logout invalidates a user session and removes the JWT token.
func (l AuthenticationBusinessLayer) Logout(
	ctx context.Context,
	jwtEncoded string,
	jwt session_manager_models.JWT,
	session session_manager_models.UntypedSession,
	ip string,
) error {
	return session_manager.Delete(ctx, jwtEncoded, jwt, session)
}

// buildLoginResponse constructs the login response with JWT token and session.
func (l AuthenticationBusinessLayer) buildLoginResponse(
	ctx context.Context,
	userID uid.UID,
	email string,
	channel session_manager_models.SessionChannel,
	ip string,
	entities []session_manager_models.JWTEntity,
	userType auth_entities.UserTypeEnum,
) (auth.LoginResponse, error) {
	var loginResp auth.LoginResponse
	var err error

	timeNow := time.Now()
	jwt, err := session_manager.GenerateJWT(ctx, userID, email, ip, channel, entities)
	if err != nil {
		return loginResp, err
	}
	logger.Debug("elapsed on generate token %d ms", time.Since(timeNow).Milliseconds())

	var userSession session_manager_models.UntypedSession
	switch userType {
	case auth_entities.SuperAdminUserType:
		adminSession := session_manager.GenerateAdminSessionFromJWT(ctx, jwt)
		userSession = adminSession.UntypedSession
	case auth_entities.UserType:
		partnerSession := session_manager.GenerateUserSessionFromJWT(ctx, jwt)
		userSession = partnerSession.UntypedSession
	default:
		pixiecontext.GetCtxLogger(ctx).With("user_type", userType).Error("unknown user type, no session created")
		return auth.LoginResponse{}, errors.New("unknown user type %d", userType).WithErrorCode(errors.UnknownErrorCode)
	}

	return auth.LoginResponse{Token: jwt.EncodedJWT}, session_manager.Save(ctx, jwt, userSession)
}

// Defer performs cleanup operations.
func (l AuthenticationBusinessLayer) Defer() {}

// ListSessions retrieves all active sessions.
func (l AuthenticationBusinessLayer) ListSessions(ctx context.Context) (any, error) {
	return session_manager.GetSessions(ctx)
}

// GetSessionBySessionID retrieves a specific session by its ID.
func (l AuthenticationBusinessLayer) GetSessionBySessionID(ctx context.Context, sessionID string) (struct {
	TokenData   session_manager_models.JWT `json:"token_data"`
	TokenString string                     `json:"token_string"`
}, error) {
	token, tokenStr, err := session_manager.GetManager().GetJWTTokenBySessionID(ctx, sessionID)
	if err != nil {
		return struct {
			TokenData   session_manager_models.JWT `json:"token_data"`
			TokenString string                     `json:"token_string"`
		}{}, err
	}

	return struct {
		TokenData   session_manager_models.JWT `json:"token_data"`
		TokenString string                     `json:"token_string"`
	}{
		TokenData:   token,
		TokenString: tokenStr,
	}, nil
}

// GetSessionsOfUserByUserID retrieves all sessions for a specific user.
func (l AuthenticationBusinessLayer) GetSessionsOfUserByUserID(ctx context.Context, userID uid.UID) (struct {
	UserID       uint64                       `json:"user_id"`
	SessionIDs   []string                     `json:"session_ids"`
	SessionsData []session_manager_models.JWT `json:"session_data"`
}, error) {
	return session_manager.GetManager().GetJWTSessionsByUserID(ctx, userID)
}

// DeleteSessionBySessionID removes a specific session by its ID.
func (l AuthenticationBusinessLayer) DeleteSessionBySessionID(ctx context.Context, sessionID string) error {
	return session_manager.DeleteSession(ctx, sessionID)
}
