package authentication_services

import (
	"context"
	"strconv"
	"time"

	pixiecontext "github.com/pixie-sh/core-go/pkg/context"
	"github.com/pixie-sh/core-go/pkg/services"
	"github.com/pixie-sh/core-go/pkg/uid"
	"github.com/pixie-sh/core-go/pkg/utils"
	"github.com/pixie-sh/di-go"

	internaldi "{{ .ModuleName }}/infra/di"

	data "{{ .ModuleName }}/internal/domains/authentication/authentication_data_layer"
	"{{ .ModuleName }}/internal/domains/authentication/authentication_data_layer/auth_entities"
)

type PasswordServiceConfiguration struct {
	PasswordResetTTLMillis         uint64                              `json:"password_reset_ttl_millis"`
	PasswordDataLayerConfiguration data.PasswordDataLayerConfiguration `json:"password_data_layer"`
}

func (p PasswordServiceConfiguration) LookupNode(lookupPath string) (any, error) {
	return di.ConfigurationNodeLookup(p, lookupPath)
}

type PasswordService struct {
	services.Service[PasswordService]

	config    *PasswordServiceConfiguration
	dataLayer *data.PasswordDataLayer
}

func RegistryPasswordServiceConfiguration(ctx di.Context, opts *di.RegistryOpts) (*PasswordServiceConfiguration, error) {
	return di.ConfigurationLookup[*PasswordServiceConfiguration](ctx, opts)
}

func RegistryPasswordService(ctx di.Context, opts *di.RegistryOpts) (*PasswordService, error) {
	log := pixiecontext.GetCtxLogger(ctx)

	cfg, err := di.CreateConfiguration[*PasswordServiceConfiguration](ctx, di.WithOpts(opts))
	if err != nil {
		return nil, err
	}

	passwordDataLayer, err := di.Create[*data.PasswordDataLayer](ctx, di.WithOpts(opts), di.WithToken(internaldi.RegistryTokenPasswordDataLayer))
	if err != nil {
		log.With("err", err).Error("Failed to initialize %s for %s", internaldi.RegistryTokenPasswordDataLayer, internaldi.RegistryTokenPasswordService)
		return nil, err
	}

	return NewPasswordService(ctx, cfg, passwordDataLayer)
}

func NewPasswordService(_ context.Context, config *PasswordServiceConfiguration, dataLayer *data.PasswordDataLayer) (*PasswordService, error) {
	os := PasswordService{
		config:    config,
		dataLayer: dataLayer,
	}

	os.Service = services.NewService(&os, NewPasswordServiceFrom)
	return &os, nil
}

func NewPasswordServiceFrom(service services.Service[PasswordService]) (*PasswordService, *services.Service[PasswordService]) {
	us := &PasswordService{}
	us.config = service.Instance.config
	us.dataLayer = service.Instance.dataLayer
	us.Service = services.NewService(us, nil)

	return us, &us.Service
}

func (l PasswordService) CreateNewResetToken(_ context.Context, ip string, agent string, userID uid.UID) (auth_entities.PasswordReset, error) {
	passwordRepository := l.dataLayer.PasswordRepository
	if !l.TxNil() {
		passwordRepository = l.dataLayer.PasswordRepository.WithTx(l.Tx)
	}

	strRandomNumber := strconv.Itoa(utils.RandomValue())
	ttlDuration := time.Duration(l.config.PasswordResetTTLMillis) * time.Millisecond
	validUntil := time.Now().Add(ttlDuration)
	return passwordRepository.CreateNewReset(userID, ip, agent, strRandomNumber, validUntil)
}

func (l PasswordService) VerifyUnusedResetTokensForUserID(ctx context.Context, userID uid.UID) ([]auth_entities.PasswordReset, error) {
	passwordResets, err := l.FindUnusedPasswordResetsForUserID(ctx, userID)
	if err != nil {
		return nil, err
	}

	var expiredPasswordResets []uid.UID
	var validPasswordResets []auth_entities.PasswordReset
	now := time.Now()

	PasswordRepository := l.dataLayer.PasswordRepository
	if !l.TxNil() {
		PasswordRepository = l.dataLayer.PasswordRepository.WithTx(l.Tx)
	}

	for _, code := range passwordResets {
		if code.ValidUntil.Before(now) {
			expiredPasswordResets = append(expiredPasswordResets, code.ID)
		} else {
			validPasswordResets = append(validPasswordResets, code)
		}
	}

	if len(expiredPasswordResets) > 0 {
		err = PasswordRepository.MarkInvalidAsExpired(expiredPasswordResets)

		if err != nil {
			return nil, err
		}
	}

	return validPasswordResets, nil
}

func (l PasswordService) FindUnusedPasswordResetsForUserID(_ context.Context, userID uid.UID) ([]auth_entities.PasswordReset, error) {
	passwordRepository := l.dataLayer.PasswordRepository
	if !l.TxNil() {
		passwordRepository = l.dataLayer.PasswordRepository.WithTx(l.Tx)
	}

	return passwordRepository.FindUnusedForUserID(userID)
}

func (l PasswordService) MarkAsConfirmed(_ context.Context, otpID uid.UID) error {
	otpRepository := l.dataLayer.PasswordRepository
	if !l.TxNil() {
		otpRepository = l.dataLayer.PasswordRepository.WithTx(l.Tx)
	}

	return otpRepository.MarkAsConfirmed(otpID)
}
